#!/usr/bin/env python
from __future__ import with_statement
import argparse
import logging.handlers
import os.path
import sys
import dimclient


def pid_exists(pid):
    if pid < 0:
        return False
    try:
        os.kill(pid, 0)
    except OSError, e:
        return e.errno == errno.EPERM
    else:
        return True


def check_pidfile(pidfile):
    if os.path.isfile(pidfile):
        try:
            pid = int(open(pidfile).readline())
        except:
            remove_pidfile(pidfile)
        else:
            if pid_exists(pid):
                logging.error("Another instance is running according to pidfile: %s" % pidfile)
                exit(2)
    open(pidfile, 'w').write(str(os.getpid()))


def remove_pidfile(pidfile):
    os.remove(pidfile)


def configure_logging(debug, facility, verbose):
    # Workaround for http://bugs.python.org/issue14452
    if sys.version_info < (2, 7):
        class Formatter(logging.Formatter):
            def format(self, record):
                return logging.Formatter.format(self, record).encode('utf-8')
    else:
        Formatter = logging.Formatter

    level = logging.DEBUG if verbose else logging.INFO
    if not debug:
        handler = logging.handlers.SysLogHandler(address='/dev/log', facility=facility)
    else:
        handler = logging.StreamHandler()
    handler.setLevel(level)
    handler.setFormatter(Formatter(fmt='dim-bind-file-agent: %(message)s'))
    root_logger = logging.getLogger()
    root_logger.setLevel(level)
    root_logger.addHandler(handler)


def write_bind_file(zonefiledir, zone):
    logging.info('Writing BIND file %s' % zone['name'])
    final_path = os.path.join(zonefiledir, zone['name'])
    with open(final_path, 'w') as f:
        f.write(server.zone_dump(zone['name'], view=zone['view']))


def handle_output(output, zonefiledir, includefile):
    old_zonefiles = set(os.listdir(zonefiledir))
    zones = {}
    for zg in (v['zone_group'] for v in server.output_get_groups(output)):
        for v in server.zone_group_get_views(zg):
            zones[v['zone']] = dict(name=v['zone'],
                                    view=v['view'],
                                    updated=False)
    updates = server.output_update_list(output=output)
    for update in updates:
        zone = update['zone_name']
        if zone in zones:
            zones[zone]['updated'] = True
    # Write zonefiles for changed zones
    for zone in zones.values():
        if zone['name'] not in old_zonefiles or zone['updated']:
            write_bind_file(zonefiledir, zone)
    # Write the includefile
    with open(includefile, 'w') as include:
        for zone in zones.keys():
            zonefile_path = os.path.join(zonefiledir, zone)
            include.write('zone "%(zone)s"  IN { type master; file "%(path)s"; };\n' %
                          dict(zone=zone, path=zonefile_path))
    # Delete updates
    server.output_update_delete([u['id'] for u in updates])
    # Delete old zonefiles
    for fname in old_zonefiles - set(zones.keys()):
        logging.info('Removing zonefile %s' % fname)
        os.remove(os.path.join(zonefiledir, fname))


if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument('-s', '--server', required=True, help='dim server url')
    parser.add_argument('-u', '--username', required=True, help='dim username')
    parser.add_argument('-p', '--password', required=True, help='dim password')
    parser.add_argument('-o', '--output', required=True, help='dim output')
    parser.add_argument('-i', '--includefile', required=True, help='bind include config file')
    parser.add_argument('-z', '--zonefiledir', required=True, help='directory where zone files are written')
    parser.add_argument('-P', '--pidfile', help='pidfile')
    parser.add_argument('-d', '--debug', action='store_true', help='print messages to stderr instead of syslog')
    parser.add_argument('-v', '--verbose', action='store_true', help='more messages')
    parser.add_argument('-f', '--facility', default='local0', help='syslog facility (default: local0)')
    config = parser.parse_args()

    configure_logging(config.debug, config.facility, config.verbose)

    if config.pidfile is not None:
        check_pidfile(config.pidfile)
    try:
        server = dimclient.DimClient(config.server)
        server.login(config.username, config.password, True)
        output_type = server.output_get_attrs(config.output)['type']
        if output_type != 'bind':
            logging.warn('Output %s has type %s but it must be bind' % (output, output_type))
            exit(1)
        handle_output(config.output, config.zonefiledir, config.includefile)
    except Exception, e:
        logging.error(str(e), exc_info=True)
        exit(1)
    finally:
        if config.pidfile is not None:
            remove_pidfile(config.pidfile)
